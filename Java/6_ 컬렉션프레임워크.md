# 컬렉션 프레임워크

> ## Index
> #### 1. 컬렉션 프레임워크와 핵심인터페이스
> #### 2. ArrayList & LinkedList
> #### 3. Stack & Queue
> #### 5. 열거형
> #### 6. Arrays
> #### 7. Comparator, Comparable
> #### 8. HashSet
> #### 9. TreeSet
> #### 10. HashMap & HashTable
> #### 11. TreeMap
> #### 12. Properties
> #### 13. Collections
> #### 14. 정리 및 요약

  

## 1. 컬렉션 프레임워크와 핵심인터페이스

#### 1-1. 컬렉션 프레임워크란
* 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합.
    - 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 인터페이스를 사용하여 구현해놓은 것을 의미한다.
#### 1-2. 핵심 인터페이스
* 컬렉션 프레임워크에서는 자료구조의 형태에따라 크게 3가지의 형태로 분류하고 있다.
    - List, Set, Map  
        세가지의 자료구조 형태가 있는데 이중 List와 Set의경우 공통된 부분이 많아 Collection을 공통된 부모로 상속받고있다.
* Collection
    - Collection의 메서드들은 `저장된 데이터를 읽거나 추가 또는 삭제하는등의 기본적인 메서드`들을 가지고있다.(하단 이미지 참조)
    - 반환타입이 Boolean인 메서드들은 작업을 성공할경우 true, 실패하면 false를 반환한다.
    - 또한 표에서 들어간 Object가 E, T, K, V등이 들어가있는 경우도 있는데 지네릭스에 의한 표기로 일단 Object타입으로 이해하고 있으면 된다.
    - ![Collection메서드](img/Collection.png)
* List
    - `순서가 있는` 데이터의 집합, 데이터의 중복을 허용한다.  
    class) ArrayList, LinkedList, Stack, Vector등
    - 저장순서가 유지되며, 중복을 허용해야할경우 사용한다.
    - ![List메서드](img/List.png)
    ``` java
    ArrayList<Object> list = new ArrayList<Object>();
    ```
* Set
    - `순서가 없는` 데이터의 집합, `중복을 허용하지 않는다.`  
    class) HashSet, TreeSet등
    - 중복을 허용하지 않고 저장순서가 상관없을경우 사용한다.
    ``` java
    Set<Object> getSet = new HashSet<>();
    ```
* Map
    - `key와 value의 쌍`으로 이루어진 데이터의 집합
    - 순서가 없으며 key는 중복을 허용하지 않고, value는 중복된 값이 들어갈 수 있다. 
    - 만약 중복된 key로 값을 저장 할 경우 마지막에 할당한 값이 저장된다. 
    class) HashMap, TreeMap, HashTable, Properties등
    - ![Map메서드](img/Map.png)
    - values()에서는 map의경우 value값은 중복을 허용하기 때문에 collection타입으로 반환하고  
    keySet()에서는 key는 중복을 허용하지 않기때문에 set타입으로 반환한다. 
    ``` java
    Map<String, Object> resMap = new HashMap<String, Object>();
    ```
* Map과 Set을 이용한 맵 객체의 값 찾기
``` java 
public static void main(String[] args) {
    
    Map<String, Object> resMap = new HashMap<String, Object>();
    resMap.put("name", "김철수");
    resMap.put("age", "25");
    resMap.put("number", "010-1234-5566");
    resMap.put("e-mail", "kcs@maver.com");
    
    Set<String> getKey = resMap.keySet();
    Iterator<String> getItr = getKey.iterator();
    
    while (getItr.hasNext()) {
        String key = getItr.next();
        Object value = resMap.get(key);
        System.out.println("키의 값은 " + key + "이고 벨류의 값은 " + value + "입니다.");
        /* 결과값 : 
        키의 값은 number이고 벨류의 값은 010-1234-5566입니다.
        키의 값은 name이고 벨류의 값은 김철수입니다.
        키의 값은 e-mail이고 벨류의 값은 kcs@maver.com입니다.
        키의 값은 age이고 벨류의 값은 25입니다.
        */
    }
}
```
* 각 자료구조마다의 특성이 다르기때문에 필요로하는 컬렉션의 특징을 잘 파악하고 적절한 자료구조를 사용햐야한다.
* Vector, Stack, HashTable, Properties와 같은 클래스는 컬렉션프레임워크가 만들어진 이전부터 사용되던 자료구조이기 때문에 호환을 위해 남겨졌지만 가능하면 사용하지 않는것이 좋다고 한다. (성능면에서도 우수하다고한다.)

  

## 2. ArrayList & LinkedList
### 2-1. ArrayList
* ArrayList는 List의 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다는 특징이 있다.
* ArrayList는 Object배열을 이용하여 데이터를 순차적으로 저장한다.
    - 만약 데이터를 더이상 저장할 공간이 없다면 보다 큰 새로운 배열을 생성하여 기존 배열에 저장된 내용을 새로운 배열로 복사한 다음 저장된다.
    - 이때 기존의 인스턴스를 재사용하는것이 아니라 새로운 인스턴스를 만드는것에 주의해야한다.
    - 또한 용량을 변경해야 할경우 효율이 상당히 떨어지기때문에 저장할 데이터의 갯수를 잘 고려하여 충분한 용량의 인스턴스를 생성하는것이 좋다.
* 기본형인 Array`String[] arr = new String[3];`과 다른점은 길이가 지정되어있지 않고, 데이터의 추가가 자유롭다는 점이다.  
    만약 데이터의양이 동적으로 변화되는 경우라면 List를 사용하는 것이 바람직하다.
``` java 
public static void main(String[] args) {
    
    ArrayList<Object> arrList1 = new ArrayList();
    ArrayList<Object> arrList2 = new ArrayList();
    arrList1.add("a");	
    arrList1.add("c");	
    arrList1.add("b");	
    arrList1.add("d");
    arrList2.add("c");
    arrList2.add("d");
    arrList2.add("f");

    System.out.println(arrList1);   // 결과값 : [a, c, b, d]
    System.out.println(arrList2);   // 결과값 : [c, d, f]

    System.out.println(arrList1.retainAll(arrList2));   // 결과값 : true (값에 변화가 있었기때문에 true로 return)

    System.out.println(arrList1);   // 결과값 : [c, d] (공통된부분이 삭제되었다.)
    System.out.println(arrList2);   // 결과값 : [c, d, f]   
}

```
* ArrayList의 메서드들
![ArrayList 메서드](img/ArrayList.png)
``` java
public static void main(String[] args) {
    
    ArrayList<Object> arrList1 = new ArrayList();
    arrList1.add("a");	
    arrList1.add("c");	
    arrList1.add("b");	
    arrList1.add("d");
    
    // List의 마지막부터 데이터를 지우기
    for (int cnt = arrList1.size() -1; cnt >= 0; cnt--) {
        arrList1.remove(cnt);
        System.out.println(arrList1);   // 결과값 : [a, c, b] / [a, c] / [a] / []
    }
}
```
* 리스트의 마지막부터 데이터를 지울경우 System.arraycopy()를 호출하지 않기 때문에 작업시간이 짧게 걸린다.

  

### 2-1. LinkedList
* 배열은 자료구조가 간단하고 사용하기 쉬우며 데이터를 읽어오는데 걸리는 시간이 적다는 장점을 가지고 있지만, 아래와 같은 단점을 가지고있다.
    - 크기를 변경할 수 없다.  
        크기를 변경활 수 없으므로 새로운 배열을 생성해서 데이터를 복사하는 작업이 필요하다.
    - 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.  
        차례대로 데이터를 추가하고 마지막부터 삭제하는것은 빠르지만 배열의 중간에 데이터를 추가하려고 한다면 다른데이터를 복사해서 이동해야하기 때문이다.
* 위와같은 배열의 단점을 보완하기 위하여 LinkedList라는 자료구조가 고안되었다.
* 배열은 모든 데이터가 연속적으로 존재하지만 LinkedList는 비연속적인 데이터를 서로 연결하는 형태로 구성되어있다.
![LinkedList의 자료구조](img/aboutLinkedList.png)
* 위와같이 LinkedList의 각 요소들은 자신과 연결된 다음요소에대한 참조값과 데이터로 구성되어있다.
* LinkedList는 참조값으로 이루어져있기 때문에 참조만 변경하면 삭제/추가의 작업이 이루어진다.  
    따라서 배열처럼 데이터를 이동하기 위해 복사하는 과정이 없기때문에 처리속도가 매우빠르다.
* 다만 LinkedList는 이동방향이 단방향으로 이루어져있기 때문에 다음요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵다.  
    이점을 보완한것이 double Linked List(이중연결리스트)이다.
    - double Linked List는 참조변수를 하나 더 추가하여 다음요소에 대한 참조와 이전요소에 대한 참조가 가능하도록 변경한 것일뿐 다른것은 LinkedList와 동일하다.
    - double Linked List는 각 요소에 대한 접근이 용이하기 때문에 LinkedList보다 더 많이 사용된다.
    - 또한 요소에 대한 접근성을 좀더 향상시킨 방법이 double circular Linked List인데 리스트의 첫번째 요소와 마지막 요소를 서로 연결시킨 형태로 LinkedList클래스는 낮은 접근성을 높이기 위해 해당 방법으로 구성되어있다.
![LinkedList의 메서드](img/LinkedList.png)
* LinkedList또한 List의 인터페이스를 구현했기 때문에 제공하는 메서드의 종류와 기능은 거의 같다.
* LinkedList는 불연속적으로 위치한 요소들이 연결된 것이므로 데이터의 갯수가 많아질수록 데이터를 읽어오는 시간(접근시간)이 길어진다는 단점이 있다.


  
## 3. Stack & Queue
![Stack과 Queue의 자료구조](img/StackQueue.png)
* Stack
    - LIFO(Last in First out)구조로 되어있다.
    - 넣은 순서와 꺼내는 순서가 반대로 된다.
    - 마지막에 넣은 요소가 삭제되기 때문에 Stack을 클래스로 구현한다면 ArrayList로 구현하는것이 바람직하다.
    ![Stack의 메서드](img/Stack.png)
    - Stack은 컬렉션 프레임워크가 나오기 전부터 존재했기 때문에 ArrayList가 아닌 Vector를 상속받아 구현되었다.
* Queue
    - FIFO(First in First out)구조로 되어있다.
    - 넣은 순서와 꺼내는 순서가 동일하다.
    - 처음요소가 삭제되기때문에 ArrayList로 구현할경우 빈공간을 채우기 위해 복사가 이루어지므로 비효율적이게 된다. 따라서 LinkedList로 구현하는것이 바람직하다.
    ![Queue의 메서드](img/Queue.png)
* Stack과 Queue의 꺼내지는 순서
``` java
public static void main(String[] args) {
    
    Stack<String> stack = new Stack<>();
    Queue<String> queue = new LinkedList<>();
    // Queue는 클래스로 제공되지 않기때문에 인터페이스를 구현한 구현체를 사용하였다.
    
    stack.push("a");
    stack.push("b");
    stack.push("c");
    queue.offer("a");
    queue.offer("b");
    queue.offer("c");
    
    System.out.print("stack : ");
    while (!stack.isEmpty()) {
        System.out.print(stack.pop());  // 결과값 : stack : cba
    }
    System.out.println();

    System.out.print("queue : ");
    while (!queue.isEmpty()) {
        System.out.print(queue.poll()); // 결과값 : queue : abc
    }
}
```


## 5. 열거형
## 6. Arrays
## 7. Comparator, Comparable
## 8. HashSet
## 9. TreeSet
## 10. HashMap & HashTable
## 11. TreeMap
## 12. Properties
## 13. Collections
## 14. 정리 및 요약